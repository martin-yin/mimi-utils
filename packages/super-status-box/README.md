```ts
enum OrderStatus {
  /** 待付款 */
  PENDING_PAYMENT = "0"
  /** 已发货 */
  DELIVERED = "2"
}
```

### 场景

1.  场景 1

    `「table 页」`用到 Order 模块的 `OrderStatus` 枚举

    在`「table 页」`中，有`「table-search」「table-data」`这两处地方用到枚举。

    `「table-search」`中渲染时，需要的格式为 `Enum`，即 **`{ "0": "待付款", "2": "已发货" }`** （此处的「待付款」「已发货」是统一的文案」）

    而在`「table-data」`中渲染时，需要的格式为 `Options`，即 **`[{ value: "0", label: "待付款" }, { value: "2", label: "已发货" }]`** （此处的「待付款」「已发货」是统一的文案」）

    以上情况，以证明『它们需要用到`「两种数据转换」`的方法』，分别是`「toEnum」「toOptions」`

2.  场景 2

    另外，又在`「form 页」`用到 `OrderStatus` 枚举

    此时，`「form 页」`中的`「select 控件」`渲染时，需要的格式为 `Options`，即 **`[{ value: "0", label: "待付款(有权调整)" }, { value: "2", label: "运送中" }]`** （此处的文案和上面`「table 页」`中的文案不一样）

    不一样后，按理说就得`写方法`来转换。紧接着又得用上 `OrderStatus` 这个枚举作为核心。

    ***

    渐渐的，为了处理`「不一样的文案」「转换为 Enum」「转换为 Options」`这几个场景而堆积下来的 `函数复用、过程复用`，就有点不太理想的感觉了。

3.  场景 3

    又有一个 `「table 页」` 用到 `OrderStatus` 枚举

    但这个 `「table 页」` 的情况特殊一点，只用 `OrderStatus` 枚举里的 `「待付款」`，且将其转为 `Enum` 格式而提供给组件内部渲染（这里就不说是否统一文案了，如果不是，又是个麻烦的情况）

    只用 `OrderStatus` 里的一部分，即 `Pick`，此处是简单的 `Pick` 一个 `「待付款」`，然而实际场景中，可能不止一个。甚至会因所处的环境（if）而变得复杂起来

    ***

    到了这一步…又迎来了一个 `Pick` 场景，然而还有 `Omit`，以及其他…如上场景都是常发生的，并未做过度的假设。
